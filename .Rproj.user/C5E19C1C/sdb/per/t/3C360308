{
    "collab_server" : "",
    "contents" : "#' @title Extracting top driving genes driving GoM clusters\n#'\n#' @description This function uses relative gene expression profile of the GoM\n#'        clusters and applies a KL-divergence based method to\n#'        obtain a list of top features that drive each of the clusters.\n#'\n#' @param theta \\eqn{\\boldsymbol{theta}} matrix, the relative gene expression profile of the GoM clusters\n#'                (cluster probability distributions)\n#'                from the GoM model fitting (a \\eqn{G x K} matrix where \\eqn{G} is\n#'                number of features, \\eqn{K} number of topics).\n#' @param top_features  The top features in each cluster \\eqn{k} that are selected based on the feature's\n#'                          ability to distinguish cluster \\eqn{k} from cluster \\eqn{1, \\dots, K}\n#'                          for all cluster \\eqn{k \\ne l}. Default: \\eqn{10}.\n#' @param method  The underlying model assumed for KL divergence measurement.\n#'                  Two choices considered are \"bernoulli\" and \"poisson\". Default: poisson.\n#' @param options if \"min\", for each cluster k, we select features that\n#'                  maximize the minimum KL divergence of cluster k against\n#'                  all other clusters for each feature. If \"max\", we select\n#'                  features  that maximize the maximum KL divergence of cluster\n#'                  k against all other clusters for each feature.\n#'\n#' @return A matrix (K x top_features) which tabulates in k-th row the\n#'        top feature indices driving the cluster k.\n#'\n#'\n#' @examples\n#' data(\"MouseDeng2014.FitGoM\")\n#' theta_mat <- MouseDeng2014.FitGoM$clust_6$theta;\n#' top_features <- ExtractTopFeatures(theta_mat, top_features=100,\n#'                                   method=\"poisson\", options=\"min\");\n#'\n#' @export\n\nExtractTopFeatures <- function(theta,\n                               top_features = 10,\n                               method = c(\"poisson\",\"bernoulli\"),\n                               options=c(\"min\", \"max\"))\n{\n    if (is.null(method)) {\n        warning(\"method is not specified! Default method is Poisson distribution.\")\n        method <- \"poisson\"\n    }\n    if(method==\"poisson\") {\n        KL_score <- lapply(1:dim(theta)[2], function(n) {\n            out <- t(apply(theta, 1, function(x){\n                y=x[n] *log(x[n]/x) + x - x[n];\n                return(y)\n            }));\n            return(out)\n        })\n    }\n\n    if(method==\"bernoulli\"){\n        KL_score <- lapply(1:dim(theta)[2], function(n) {\n            out <- t(apply(theta, 1, function(x){\n                y=x[n] *log(x[n]/x) + (1 - x[n])*log((1-x[n])/(1-x));\n                return(y)\n            }));\n            return(out)\n        })\n    }\n\n    indices_mat=matrix(0,dim(theta)[2],top_features);\n\n    if(dim(theta)[2]==2){\n        for(k in 1:dim(theta)[2])\n        {\n            temp_mat <- KL_score[[k]][,-k];\n            if(options==\"min\"){\n                vec <- apply(as.matrix(temp_mat), 1, function(x) min(x))}\n            if(options==\"max\"){\n                vec <- apply(as.matrix(temp_mat), 1, function(x) max(x))}\n            #vec <- temp_mat;\n            ordered_kl <- order(vec, decreasing = TRUE);\n            counter <- 1\n            flag <- counter\n            while(flag <= top_features)\n            {\n                if(which.max(theta[ordered_kl[counter],])==k){\n                    indices_mat[k, flag] <- ordered_kl[counter];\n                    flag <- flag + 1;\n                    counter <- counter + 1;}\n                else{\n                    counter <- counter + 1;\n                }\n            }\n        }\n\n    } else{\n        for(k in 1:dim(theta)[2])\n        {\n            temp_mat <- KL_score[[k]][,-k];\n            if(options==\"min\"){\n                vec <- apply(temp_mat, 1, function(x) min(x))}\n            if(options==\"max\"){\n                vec <- apply(temp_mat, 1, function(x) max(x))}\n\n            ordered_kl <- order(vec, decreasing = TRUE);\n            counter <- 1\n            flag <- counter\n            while(flag <= top_features)\n            {\n                if(counter > dim(theta)[1]){\n                  indices_mat[k,(flag:top_features)]=NA;\n                  break\n                }\n                if(which.max(theta[ordered_kl[counter],])==k){\n                    indices_mat[k, flag] <- ordered_kl[counter];\n                    flag <- flag + 1;\n                    counter <- counter + 1;\n                } else {\n                    counter <- counter + 1;\n                }\n            }\n        }\n    }\n\n    return(indices_mat);\n}\n",
    "created" : 1478396731668.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3191690390",
    "id" : "3C360308",
    "lastKnownWriteTime" : 1478400309,
    "last_content_update" : 1478400309121,
    "path" : "~/Desktop/CountClust/R/ExtractTopFeatures.R",
    "project_path" : "R/ExtractTopFeatures.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}